# Commands covered:  display code
#
# This file contains a collection of tests for the style widget command of
# the tktreectrl extension.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2000 by Scriptics Corporation.
# Copyright (c) 2002 by Christian Krone.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# CVS: @(#) $Id$

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import ::tcltest::*
}

package require Tk
package require treectrl

test display-0.1 {some needed preparations} -body {

    # The size of the window is important.
    pack [treectrl .t -width 500 -height 400]

    .t element create e1 text -text "Hello,"
    .t element create e2 window -destroy yes
    .t element create e3 text -text " world!"

    .t style create S1
    .t style elements S1 {e1 e2 e3}
    .t style layout S1 e2 -iexpand x -squeeze x

    .t column create -text "Column 0" -tags C0 -itemstyle S1
    .t column create -text "Column 1" -tags C1 -itemstyle S1
    .t column create -text "Column 2" -tags C2 -itemstyle S1
    .t column create -text "Column 3" -tags C3 -itemstyle S1

    foreach I [.t item create -count 10 -parent root] {
	foreach C [.t column list] {
	    .t item element configure $I $C e2 -window [entry .t.w${I}C$C]
	}
    }

    update ; # make sure it is visible
} -result {}

test display-1.1 {<ItemVisibility>: hide some items} -body {
    .t notify bind .t <ItemVisibility> {
	puts -nonewline "%P visible=[list [lsort -integer %v]] hidden=[list [lsort -integer %h]]"
    }
    .t item configure {list {2 5 9}} -visible no
    update idletasks
} -output {<ItemVisibility> visible={} hidden={2 5 9}}

test display-1.2 {<ItemVisibility>: show some items} -body {
    .t item configure {list {9 2}} -visible yes
    update idletasks
} -output {<ItemVisibility> visible={2 9} hidden={}}

test display-1.3 {<ItemVisibility>: hide & show some items} -body {
    .t item configure {list {5}} -visible yes
    .t item configure {list {6 7}} -visible no
    update idletasks
} -output {<ItemVisibility> visible=5 hidden={6 7}}

test display-1.4 {<ItemVisibility>: delete an item when it becomes visible} -body {
    .t notify bind .t <ItemVisibility> {
	%T item delete {list %v}
    }
    .t notify bind .t <ItemDelete> {
	puts -nonewline "%P [list [lsort -integer %i]]"
    }
    .t item configure 6 -visible yes
    # Deleting an item that is being displayed should not segfault.
    update idletasks
} -output {<ItemDelete> 6}

test display-2.1 {<Configure>: resizing a column resizes a window element} -body {
    set w [.t item element cget 2 C1 e2 -window]
    bind $w <Configure> {
	puts -nonewline "<Configure> %W"
    }
    .t column configure C1 -width 100
    update idletasks
} -output {<Configure> .t.w2C1}

test display-2.2 {<Configure>: delete a column when a window in a previous column is resized during a display update} -body {
    set w [.t item element cget 2 C1 e2 -window]
    bind $w <Configure> {+
	.t column delete C2
    }
    .t column configure C1 -width 150
    # Deleting a column while displaying an item should not segfault.
    update idletasks
} -output {<Configure> .t.w2C1}

test display-2.3 {<Configure>: delete a column when a window in a previous column is resized during a display update} -body {
    set w [.t item element cget 2 C1 e2 -window]
    bind $w <Configure> {
	.t item delete 2
    }
    .t column configure C1 -width 100
    # Deleting an item while displaying it should not segfault.
    update idletasks
} -output {<ItemDelete> 2}

test display-3.1 {<Scroll>} -body {
    .t configure -width 200
    update idletasks
    .t notify bind .t <Scroll-x> {
	puts -nonewline "%P"
    }
    .t xview moveto 1.0
    update idletasks
} -output {<Scroll-x>}

test display-3.2 {<Scroll>: delete an item while scrolling} -body {
    .t notify bind .t <Scroll-x> {
	.t item delete 8
	.t notify unbind .t <Scroll-x>
    }
    .t xview moveto 0.0
    # Causing a display update while scrolling (during a display update) should
    # restart the display update and not operate on deleted items.
    update idletasks
} -output {<ItemDelete> 8}

test display-3.3 {delete the tree during a display update} -body {
    .t notify bind .t <ItemVisibility> {
	destroy .t
    }
    .t item configure 4 -visible no
    update idletasks
    winfo exists .t
} -result {0}

# Create a 40x40 item
# Check bounds via [item bbox], [marquee identify] and [item id "nearest x y"]
# Configure -canvaspadx and -canvaspady with positive values
# Check item bounds
# Create another 40x40 item to right of the first (horizontal layout)
# Check item bounds
# Configure -itemgapx with positive value
# Check item bounds

test display-4.1 {item layout} -setup {
    catch {destroy .t}
    pack [treectrl .t -width 500 -height 500]
    .t configure -showroot 0 -showheader 0 -highlightthickness 0 \
	-borderwidth 0 -orient horizontal
    .t column create -tags C1
    .t element create E1 rect -width 40 -height 40
    .t style create S1
    .t style elements S1 [list E1]
    .t item create -parent root -tags I1
    .t item style set I1 C1 S1
    update ; # make sure it is visible
} -body {
    .t item bbox I1
} -result {0 0 40 40}

test display-4.2 {item layout} -setup {
    .t configure -canvaspadx 10
} -body {
    .t item bbox I1
} -result {10 0 50 40}

test display-4.3 {item layout} -setup {
    .t configure -canvaspadx 0 -canvaspady 10
} -body {
    .t item bbox I1
} -result {0 10 40 50}

test display-4.4 {item layout} -setup {
    .t configure -canvaspadx 10 -canvaspady 10
} -body {
    .t item bbox I1
} -result {10 10 50 50}

test display-4.5 {item layout} -body {
    .t identify 0 0
} -result {}

test display-4.6 {item layout} -body {
    .t identify 9 9
} -result {}

test display-4.7 {item layout} -body {
    .t identify 50 50
} -result {}

test display-4.8 {item layout} -body {
    .t identify 50 10
} -result {}

test display-4.9 {item layout} -body {
    .t identify 10 50
} -result {}

test display-4.10 {item layout} -body {
    .t identify 10 10
} -result {item 1 column 0 elem E1}

test display-4.11 {item layout} -body {
    .t identify 49 10
} -result {item 1 column 0 elem E1}

test display-4.12 {item layout} -body {
    .t identify 10 49
} -result {item 1 column 0 elem E1}

test display-4.13 {item layout} -setup {
    .t item create -parent root -tags I2
    .t item style set I2 C1 S1
} -body {
    .t item bbox I2
} -result {50 10 90 50}

test display-4.14 {item layout} -body {
    .t identify 50 10
} -result {item 2 column 0 elem E1}

test display-4.15 {item layout} -body {
    .t identify 90 10
} -result {}

test display-4.16 {item layout} -body {
    .t item id "nearest 0 0"
} -result {1}

test display-4.17 {item layout} -body {
    .t item id "nearest 10 10"
} -result {1}

test display-4.18 {item layout} -body {
    .t item id "nearest 100 100"
} -result {2}

test display-4.19 {item layout} -body {
    .t marquee coords 0 0 100 10
    .t marquee identify
} -result {}

test display-4.20 {item layout} -body {
    .t marquee coords 0 50 100 60
    .t marquee identify
} -result {}

test display-4.21 {item layout} -body {
    .t marquee coords 90 0 100 100
    .t marquee identify
} -result {}

test display-4.22 {item layout} -body {
    .t marquee coords 10 10 11 11
    .t marquee identify
} -result {{1 {0 E1}}}

test display-4.23 {item layout} -body {
    .t marquee coords 50 10 51 11
    .t marquee identify
} -result {{2 {0 E1}}}

test display-4.24 {item layout} -body {
    .t marquee coords 49 10 61 11
    .t marquee identify
} -result {{1 {0 E1}} {2 {0 E1}}}

test display-4.25 {item layout} -setup {
    .t configure -itemgapx 10
} -body {
    .t item bbox I1
} -result {10 10 50 50}

test display-4.26 {item layout} -body {
    .t item bbox I2
} -result {60 10 100 50}

test display-4.27 {item layout} -body {
    .t identify 50 10
} -result {}

test display-4.28 {item layout} -body {
    .t identify 59 10
} -result {}

test display-4.29 {item layout} -body {
    .t identify 60 10
} -result {item 2 column 0 elem E1}

test display-4.30 {item layout} -body {
    .t marquee coords 50 0 60 100
    .t marquee identify
} -result {}

test display-4.31 {item layout} -body {
    .t marquee coords 100 0 110 100
    .t marquee identify
} -result {}

test display-4.32 {item layout} -body {
    .t marquee coords 10 10 60 20
    .t marquee identify
} -result {{1 {0 E1}}}

test display-4.33 {item layout} -body {
    .t marquee coords 10 10 61 20
    .t marquee identify
} -result {{1 {0 E1}} {2 {0 E1}}}

test display-4.34 {item layout} -body {
    .t item id "nearest 50 10"
} -result {1}

test display-4.35 {item layout: < half-way between} -body {
    .t item id "nearest 54 10"
} -result {1}

test display-4.36 {item layout: >= half-way between} -body {
    .t item id "nearest 55 10"
} -result {2}

test display-5.1 {item layout} -setup {
    catch {destroy .t}
    pack [treectrl .t -width 500 -height 500]
    .t configure -showroot 0 -showheader 0 -highlightthickness 0 \
	-borderwidth 0 -orient vertical -indent 20
    .t column create -tags C1
    .t configure -treecolumn C1
    .t element create E1 rect -width 100 -height 20
    .t style create S1
    .t style elements S1 [list E1]
    .t item create -button yes -parent root -tags I1
    .t item style set I1 C1 S1
    update ; # make sure it is visible
} -body {
    .t item bbox I1
} -result {0 0 120 20}

test display-5.2 {button hit-testing} -setup {
} -body {
    .t identify 0 0
} -result {item 1 button}

test display-5.3 {button hit-testing} -setup {
    .t configure -canvaspadx 20
} -body {
    .t identify 20 0
} -result {item 1 button}

test style-99.1 {some needed cleanup} -body {
    destroy .t
} -result {}

# cleanup
::tcltest::cleanupTests
return
